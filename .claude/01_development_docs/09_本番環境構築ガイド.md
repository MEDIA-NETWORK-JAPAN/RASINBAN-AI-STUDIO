# 09 本番環境構築ガイド

## 概要

ConoHa VPS（または同等のLinux VPS）上にDocker Composeで本番環境を構築するためのガイド。
開発環境（Laravel Sail）との差異と、本番固有の設定・注意点をまとめる。

---

## 1. 開発環境の pgAdmin4

### セットアップ状況

`compose.yaml` に pgAdmin4 サービスを追加済み。`vendor/bin/sail up -d` で自動起動する。

```yaml
pgadmin:
  image: dpage/pgadmin4:latest
  ports:
    - "127.0.0.1:${PGADMIN_PORT:-5050}:80"   # localhost のみ
  environment:
    PGADMIN_DEFAULT_EMAIL: "${PGADMIN_EMAIL}"
    PGADMIN_DEFAULT_PASSWORD: "${PGADMIN_PASSWORD}"
  volumes:
    - sail-pgadmin:/var/lib/pgadmin
  depends_on:
    pgsql:
      condition: service_healthy
```

### `.env` に追加する変数

```dotenv
# pgAdmin4
PGADMIN_PORT=5050
PGADMIN_EMAIL=admin@example.com
PGADMIN_PASSWORD=（任意のパスワード）
```

### アクセス方法

```
http://localhost:5050
```

ログイン後、DBサーバーを登録する。

| 項目 | 値 |
|---|---|
| Host | `pgsql`（Dockerサービス名） |
| Port | `5432` |
| Database | `.env` の `DB_DATABASE` |
| Username | `.env` の `DB_USERNAME` |
| Password | `.env` の `DB_PASSWORD` |

### ポート運用ルール

| ポート | 用途 |
|---|---|
| `5050` | 開発環境（`localhost:5050` で直接アクセス） |
| `15050` | 本番環境（SSHトンネル経由でアクセス） |

同時利用時の衝突防止のためポートを固定している。

---

## 2. 本番環境の構成

### コンテナ構成

| サービス | 役割 | イメージ |
|---|---|---|
| `app` | PHP-FPM + Laravel | `php:8.3-fpm-alpine` |
| `nginx` | リバースプロキシ・静的配信 | `nginx:alpine` |
| `db` | PostgreSQL | `postgres:16-alpine` |
| `pgadmin` | DB管理GUI（localhost限定） | `dpage/pgadmin4:latest` |

### ポート公開ルール

```
外部 → nginx:80/443 のみ許可
db:5432          → Docker内部のみ（ポートマッピングなし）
pgadmin:5050     → 127.0.0.1:5050 のみ（SSHトンネルでアクセス）
```

---

## 3. ディレクトリ構成（本番）

```
/srv/rasinban-ai-studio/         ← デプロイ先（任意）
├── docker-compose.yml
├── .env                         ← Git管理外
├── .env.example
├── docker/
│   ├── app/
│   │   └── Dockerfile
│   ├── nginx/
│   │   └── conf.d/
│   │       └── default.conf
│   └── db/
│       └── init/                ← 初期化SQL（任意）
├── src/                         ← Laravelソースコード
└── backups/                     ← DBバックアップ（Git管理外）
```

### `.gitignore` に追加すること

```gitignore
.env
backups/
```

---

## 4. Dockerfile（app コンテナ）

```dockerfile
FROM php:8.3-fpm-alpine

RUN apk add --no-cache \
    postgresql-dev \
    libzip-dev \
    icu-dev \
    && docker-php-ext-install \
        pdo_pgsql \
        pgsql \
        zip \
        intl \
        mbstring \
        opcache

# Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# 実行ユーザー（rootを避ける）
RUN addgroup -g 1000 appgroup && adduser -u 1000 -G appgroup -s /bin/sh -D appuser

WORKDIR /var/www/html

USER appuser
```

---

## 5. Nginx 設定

```nginx
server {
    listen 80;
    server_name _;
    root /var/www/html/public;
    index index.php;

    client_max_body_size 20M;

    # .well-known 以外のドットファイルへのアクセスを禁止
    location ~ /\.(?!well-known).* {
        deny all;
    }

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

    # X-Powered-By ヘッダーを非表示
    fastcgi_hide_header X-Powered-By;
}
```

---

## 6. `docker-compose.yml`（本番向け）

```yaml
services:
  app:
    build:
      context: ./docker/app
      dockerfile: Dockerfile
    volumes:
      - ./src:/var/www/html
    networks:
      - app-network
    depends_on:
      db:
        condition: service_healthy

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./src:/var/www/html
      - ./docker/nginx/conf.d:/etc/nginx/conf.d
      - /etc/letsencrypt:/etc/letsencrypt:ro   # SSL証明書
    networks:
      - app-network
    depends_on:
      - app

  db:
    image: postgres:16-alpine
    # ポートマッピングなし（内部ネットワークのみ）
    environment:
      POSTGRES_DB: "${DB_DATABASE}"
      POSTGRES_USER: "${DB_USERNAME}"
      POSTGRES_PASSWORD: "${DB_PASSWORD}"
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "pg_isready", "-q", "-d", "${DB_DATABASE}", "-U", "${DB_USERNAME}"]
      retries: 3
      timeout: 5s

  pgadmin:
    image: dpage/pgadmin4:latest
    ports:
      - "127.0.0.1:${PGADMIN_PORT:-5050}:80"   # localhost 限定
    environment:
      PGADMIN_DEFAULT_EMAIL: "${PGADMIN_EMAIL}"
      PGADMIN_DEFAULT_PASSWORD: "${PGADMIN_PASSWORD}"
    volumes:
      - pgadmin-data:/var/lib/pgadmin
    networks:
      - app-network
    depends_on:
      db:
        condition: service_healthy

networks:
  app-network:
    driver: bridge

volumes:
  db-data:
    driver: local
  pgadmin-data:
    driver: local
```

---

## 7. 本番 `.env` の設定

```dotenv
APP_NAME=rasinban-ai-studio
APP_ENV=production
APP_DEBUG=false
APP_URL=https://your-domain.example.com

DB_CONNECTION=pgsql
DB_HOST=db
DB_PORT=5432
DB_DATABASE=rasinban_prod
DB_USERNAME=（ランダムな文字列）
DB_PASSWORD=（十分に強固なパスワード）

PGADMIN_PORT=5050
PGADMIN_EMAIL=admin@your-domain.example.com
PGADMIN_PASSWORD=（十分に強固なパスワード）
```

---

## 8. ファイアウォール設定（ufw）

```bash
# デフォルト拒否
ufw default deny incoming
ufw default allow outgoing

# 許可ポート
ufw allow 22/tcp    # SSH
ufw allow 80/tcp    # HTTP
ufw allow 443/tcp   # HTTPS

ufw enable
ufw status verbose
```

**確認事項**: `5432`（PostgreSQL）と `5050`（pgAdmin）が外部に開放されていないこと。

```bash
# 外部から到達できないことを確認
ufw status | grep -E "5432|5050"
# 何も表示されなければ OK
```

---

## 9. pgAdmin へのアクセス（本番）

本番の pgAdmin は `127.0.0.1:5050` のみ公開。外部からは **SSHトンネル**で接続する。

```bash
# ローカルで実行。15050 → 本番サーバーの 5050 に転送
ssh -L 15050:127.0.0.1:5050 user@your-vps-ip -N
```

接続後、ローカルブラウザで `http://localhost:15050` にアクセス。

ポート運用ルール：
- `5050` → 開発環境（localhost直接）
- `15050` → 本番環境（SSHトンネル）

---

## 10. SSL/TLS 設定（Certbot + Let's Encrypt）

```bash
# Certbot インストール（VPS 側で実行）
apt install certbot python3-certbot-nginx

# 証明書取得（nginx コンテナが 80 で待ち受けている前提）
certbot certonly --webroot -w /srv/rasinban-ai-studio/src/public \
  -d your-domain.example.com

# 証明書は /etc/letsencrypt/ に保存される
# docker-compose.yml で :ro マウント済み
```

Nginx 設定に HTTPS ブロックを追加する。

```nginx
server {
    listen 443 ssl;
    server_name your-domain.example.com;

    ssl_certificate     /etc/letsencrypt/live/your-domain.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.example.com/privkey.pem;

    root /var/www/html/public;
    # ... 以降は HTTP 設定と同じ
}

# HTTP → HTTPS リダイレクト
server {
    listen 80;
    server_name your-domain.example.com;
    return 301 https://$host$request_uri;
}
```

---

## 11. DBバックアップ（本番）

### バックアップスクリプト

`/srv/rasinban-ai-studio/backup.sh` として保存する。

```bash
#!/bin/bash
set -euo pipefail

BACKUP_DIR="/srv/rasinban-ai-studio/backups"
COMPOSE_DIR="/srv/rasinban-ai-studio"
CONTAINER="rasinban-ai-studio-db-1"   # docker ps で実際の名前を確認
DB_NAME="${DB_DATABASE}"
DB_USER="${DB_USERNAME}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/backup_${TIMESTAMP}.dump"
LOG_FILE="${BACKUP_DIR}/backup.log"

mkdir -p "$BACKUP_DIR"

echo "[$(date '+%Y-%m-%d %H:%M:%S')] バックアップ開始: ${BACKUP_FILE}" >> "$LOG_FILE"

# pg_dump でカスタム形式バックアップ
docker exec "$CONTAINER" pg_dump \
  --format=custom \
  --username="$DB_USER" \
  "$DB_NAME" > "$BACKUP_FILE"

echo "[$(date '+%Y-%m-%d %H:%M:%S')] バックアップ完了: $(du -sh ${BACKUP_FILE} | cut -f1)" >> "$LOG_FILE"

# 30日以上前のバックアップを削除
find "$BACKUP_DIR" -name "backup_*.dump" -mtime +30 -delete
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 古いバックアップを削除しました" >> "$LOG_FILE"
```

```bash
chmod +x /srv/rasinban-ai-studio/backup.sh
```

### cron 設定

```bash
crontab -e
```

```cron
# 毎日 AM 3:00 にバックアップ実行
0 3 * * * /srv/rasinban-ai-studio/backup.sh
```

### リストア手順

```bash
# バックアップファイルを指定してリストア
docker exec -i rasinban-ai-studio-db-1 pg_restore \
  --username="${DB_USERNAME}" \
  --dbname="${DB_DATABASE}" \
  --clean \
  < /srv/rasinban-ai-studio/backups/backup_YYYYMMDD_HHMMSS.dump
```

---

## 12. 構築チェックリスト

### 初回セットアップ

- [ ] VPS に Docker / Docker Compose をインストール
- [ ] リポジトリをクローン
- [ ] `.env.example` → `.env` にコピーして本番値を設定
- [ ] `docker compose up -d --build` で起動
- [ ] `docker compose exec app composer install --no-dev`
- [ ] `docker compose exec app php artisan key:generate`
- [ ] `docker compose exec app php artisan migrate --force`
- [ ] `docker compose exec app php artisan config:cache`
- [ ] `docker compose exec app php artisan route:cache`
- [ ] ファイアウォール（ufw）設定
- [ ] SSL/TLS 設定（Certbot）
- [ ] pgAdmin でDB接続を登録・動作確認
- [ ] バックアップスクリプトを設置し cron を登録

### セキュリティチェック

- [ ] `APP_DEBUG=false` になっているか
- [ ] `APP_KEY` が設定されているか
- [ ] `DB_PASSWORD` / `PGADMIN_PASSWORD` が十分に強固か
- [ ] ポート 5432 が外部からアクセス不可か（`ufw status` で確認）
- [ ] ポート 5050 が外部からアクセス不可か
- [ ] `.env` が `.gitignore` で除外されているか
- [ ] `backups/` ディレクトリが `.gitignore` で除外されているか

---

## 13. 開発環境 vs 本番環境の差異

| 項目 | 開発（Sail） | 本番（docker-compose.yml） |
|---|---|---|
| PHP実行 | Sail内蔵コンテナ | `php:8.3-fpm-alpine` + Nginx |
| DBポート公開 | `0.0.0.0:5432` | なし（内部のみ） |
| pgAdminポート | `127.0.0.1:5050` | `127.0.0.1:5050`（SSHトンネル必須） |
| SSL | なし | Certbot + Let's Encrypt |
| APP_DEBUG | true | false |
| キャッシュ | なし | config/route キャッシュ有効 |
| Mailpit | あり | なし（本番SMTPを使用） |
